apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.14"
}

private static String capitalize(String s) {
    s ? s[0].toUpperCase() + s[1..-1] : ''
}

project.afterEvaluate {
    def buildTypes      = android.buildTypes.collect { it.name }
    def productFlavors  = android.productFlavors.collect { it.name }
    def buildDir        = layout.buildDirectory.get().asFile

    // Ensure we always iterate at least once for projects without flavors
    if (!productFlavors) productFlavors << ''

    // Patterns excluded from coverage (generated, test, and data-binding classes)
    def defaultExcludes = [
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            '**/*_Impl*.*',
            '**/*Binding.*',
            '**/*Double.*',
            '**/*Test.*',
            '**/*Test$*.class',
            '**/databinding/**',
            '**/di/**',           // adjust or remove if you want DI classes covered
    ]

    productFlavors.each { flavor ->
        buildTypes.each { buildType ->

            // e.g. "debug", "stagingRelease"
            def variantName  = flavor ? "${flavor}${capitalize(buildType)}" : buildType
            def testTaskName = "test${capitalize(variantName)}UnitTest"

            // ── Class directories ──────────────────────────────────────────
            def kotlinClasses = fileTree(
                    dir:      "${buildDir}/tmp/kotlin-classes/${variantName}",
                    excludes: defaultExcludes
            )
            def javaClasses = fileTree(
                    dir:      "${buildDir}/intermediates/javac/${variantName}/classes",
                    excludes: defaultExcludes
            )

            // ── Source directories ─────────────────────────────────────────
            def sourceDirs = [
                    "${projectDir}/src/main/kotlin",
                    "${projectDir}/src/main/java",
            ]
            if (flavor) sourceDirs << "${projectDir}/src/${flavor}/java"

            // ── Execution data ─────────────────────────────────────────────
            def execFiles = fileTree(dir: buildDir, includes: [
                    "jacoco/${testTaskName}.exec",
                    // Uncomment if you also run instrumented tests:
                    // "outputs/unit_test_code_coverage/${variantName}UnitTest/${testTaskName}.ec",
            ])

            // ── Report locations ───────────────────────────────────────────
            def reportsDir    = "${buildDir}/reports/jacoco/${variantName}"
            def xmlOutputFile = file("${reportsDir}/${variantName}.xml")
            def htmlOutputDir = file("${reportsDir}/html")

            // ── Task registration (preferred over legacy `task` syntax) ────
            tasks.register("test${capitalize(variantName)}Coverage", JacocoReport) {
                group       = "quoteunquote"
                description = "Generate JaCoCo coverage report for the '${variantName}' variant."

                dependsOn testTaskName

                classDirectories.setFrom(files(kotlinClasses, javaClasses))
                sourceDirectories.setFrom(files(sourceDirs))
                executionData.setFrom(execFiles)

                reports {
                    xml.required         = true
                    xml.outputLocation   = xmlOutputFile

                    html.required        = true
                    html.outputLocation  = htmlOutputDir

                    csv.required         = false   // flip to true if needed
                }

                // Fail the task if no execution data is present so CI catches missing test runs
                doFirst {
                    if (executionData.files.every { !it.exists() }) {
                        throw new GradleException(
                                "No JaCoCo execution data found for '${variantName}'. " +
                                        "Run '${testTaskName}' before generating the coverage report."
                        )
                    }
                }
            }
        }
    }
}
